%
%!TEX root = ../../hp3D_user_guide.tex
%

\chapter{Model Problems}
\label{chap:examples}

%--------------------------------------------------------------------

\section{Poisson Problems}
\label{sec:poisson}

For the first model problem implementation, we consider the Poisson problem with inhomogeneous Dirichlet BC:
\begin{alignat*}{3}
	- \div \nabla u &= f && \quad \text{in } \Omega \, , \\
	u &= u_0 && \quad \text{on } \Gamma \, .
\end{alignat*}

Classical variational formulation:
\[
\left\{
\begin{array}{llll}
	u \in H^1(\Omega):  u = u_0 \text{ on } \Gamma \, , \\[5pt]
	(\nabla u, \nabla v) = (f,v) \, ,
	\quad v \in H^1(\Omega) \, : \, v = 0 \text{ on } \Gamma \, .
\end{array}
\right.
\]

\subsection{Galerkin implementation}
\label{subsec:poisson-galerkin}

The Galerkin FE implementation of the problem is located in the application directory \file{problems/POISSON/GALERKIN}. In the remainder of this section, file paths may be given as relative paths within the application directory.

Input files:
\begin{itemize}
	\item{\file{control/control}: sets global control variables, e.g.
	\begin{itemize}
		\item \var{NEXACT} $\in \{$ \code{0,1} $\}$: indicates whether the exact solution is known.
		\item \var{EXGEOM} $\in \{$ \code{0,1} $\}$: indicates whether isoparametric or exact-geometry elements are used.
	\end{itemize}
	}
	\item{\file{input/physics}: sets initially allocated nodes and physics variables.
\begin{lstlisting}[caption=\file{POISSON/GALERKIN/input/physics} input file.]
100000              MAXNODS, nodes anticipated
1                   NR_PHYSA, physics attributes
field   contin  1   H1 variable
\end{lstlisting}
	\begin{itemize}
		\item The value of \var{MAXNODS} does not have to be precise; if more nodes are needed, the code allocates them on-the-fly. However, it is recommended for efficiency that the code does not reallocate, as well as not selecting \var{MAXNODS} much larger than needed.
		\item \code{\var{NR\_PHYSA}=1} specifies that \emph{one} physics variable is declared.
		\item \code{`field   contin  1'} specifies ``nickname, approximation space, number of components'' of a variable. The approximation spaces are: $H^1$ -- \code{contin}, $H(\tcurl)$ -- \code{tangen}, $H(\tdiv)$ -- \code{normal}, $L^2$ -- \code{discon}.
		\item For this Galerkin FE formulation, one $H^1$ variable is needed.
	\end{itemize}
	}
	\item{\file{geometries/hexa\_orient0}: defines the initial geometry mesh (a cube).}
\end{itemize}

Next, we take a look at the required routines that must be provided by the user:
\begin{itemize}
	\itemsep 0pt
	\item
	{\routine{set\_initial\_mesh}:\\
	for \emph{each} initial mesh element, this routine sets
	\begin{itemize}
		\item the supported physics variables;
		\item the initial polynomial order of approximation;
		\item the boundary condition flags for element faces on the boundary.
	\end{itemize}
\begin{lstlisting}[caption=\file{POISSON/GALERKIN/}\routine{set\_initial\_mesh} routine.]
!..loop over initial mesh elements
   do iel=1,NRELIS

!  ...1. set physics
      ELEMS(iel)%nrphysics = 1
      allocate(ELEMS(iel)%physics(1))
      ELEMS(iel)%physics(1) ='field'

!  ...2. set initial order of approximation
      select case(ELEMS(iel)%type)
         case('tetr'); Nelem_order(iel) = 1*IP
         case('pyra'); Nelem_order(iel) = 1*IP
         case('pris'); Nelem_order(iel) = 11*IP
         case('bric'); Nelem_order(iel) = 111*IP
      end select

!  ...3. set BC flags: 0 - no BC ; 1 - Dirichlet; 2-9 Custom BCs
      ibc(1:6,1) = 0
      do ifc=1,nface(ELEMS(iel)%type) ! loop through element faces
         neig = ELEMS(iel)%neig(ifc)
         select case(neig)
            case(0); ibc(ifc,1) = 1
         end select
      enddo

!  ...allocate BC flags (one per component), and encode face BCs into a single BC flag
      allocate(ELEMS(iel)%bcond(1))
      call encodg(ibc(1:6,1),10,6, ELEMS(iel)%bcond(1))
   enddo
\end{lstlisting}
	}
	\item
	{\routine{dirichlet}:
	\begin{itemize}
	\item User-provided routine required by the system routine \routine{update\_Ddof} which computes the Dirichlet DOFs for element nodes (vertices, edges, faces) with a non-homogeneous Dirichlet BCs. 
	\item \routine{update\_Ddof} interpolates $H^1$, $H(\tcurl)$, $H(\tdiv)$ Dirichlet data using \emph{projection-based} interpolation.\footnote{\fullcite{demkowicz2008interp}}
	\item Required only if non-homogeneous Dirichlet BCs have been set by the user in \routine{set\_initial\_mesh}.
\end{itemize}

\begin{lstlisting}[caption=\file{POISSON/GALERKIN/common/}\routine{dirichlet} routine.]
!  routine dirichlet: returns Dirichlet data at a point
!   in:   Mdle          - middle node number
!         X             - a point in physical space
!         Icase         - node case (specifies supported variables)
!   out:  ValH, DvalH   - value of the H1 solution, 1st derivatives
!         ValE, DvalE   - value of the H(curl) solution, 1st derivatives
!         ValV, DvalV   - value of the H(div) solution, 1st derivatives
subroutine dirichlet(Mdle,X,Icase, ValH,DvalH,ValE,DvalE,ValV,DvalV)
\end{lstlisting}
	}
	\item
	{\routine{elem}:
	\begin{itemize}
	\item User-provided routine that computes the element-local stiffness matrix and load vector.
	\item System module \module{assembly} provides global arrays for this purpose:
	\begin{itemize}
		\item \var{ALOC(:,:)\%array}: Element-local stiffness matrix.
		\item \var{BLOC(:)\%array}: Element-local load vector.
		\item These arrays are declared \omp{omp threadprivate} for shared-memory parallel assembly of different element matrices with OpenMP threading.
	\end{itemize}
\end{itemize}

\routine{elem} is called during assembly for each middle node \var{Mdle} in the \emph{active mesh}.

\begin{remark}
Constrained approximation, modification for Dirichlet nodes, and static condensation of element-interior (bubble) DOFs are automatically done afterwards by the system routine \routine{celem\_system} which provides the \emph{modified element} matrices to the assembly procedure.
\end{remark}

\begin{lstlisting}[mathescape,caption=\file{POISSON/GALERKIN/}\routine{elem} routine]
!..determine element type; number of vertices, edges, and faces
   etype = NODES(Mdle)%type
   nrv = nvert(etype); nre = nedge(etype); nrf = nface(etype)
   
!..determine order of approximation
   call find_order(Mdle, norder)
   
!..determine edge and face orientations
   call find_orient(Mdle, norient_edge,norient_face)
   
!..determine nodes coordinates
   call nodcor(Mdle, xnod)
   
!..set quadrature points and weights
   call set_3D_int(etype,norder,norient_face, nrint,xiloc,waloc)

!  ....... element integrals:

!..loop over integration points
   do l=1,nrint

!  ...coordinates and weight of this integration point
      xi(1:3)=xiloc(1:3,l); wa=waloc(l)

!  ...H1 shape functions (for geometry)
      call shape3DH(etype,xi,norder,norient_edge,norient_face, nrdofH,shapH,gradH)

!  ...geometry map
      call geom3D(Mdle,xi,xnod,shapH,gradH,nrdofH, x,dxdxi,dxidx,rjac,iflag)

!  ...integration weight
      weight = rjac*wa

!  ...get the RHS
      call getf(Mdle,x, fval)

!  ...loop through H1 test functions
      do k1=1,nrdofH

!     ...Piola transformation: $q \rightarrow \hat q$ and $\nabla q \rightarrow J^{-T} \hat \nabla \hat q$
         q = shapH(k1)
         dq(1:3) = gradH(1,k1)*dxidx(1,1:3) + gradH(2,k1)*dxidx(2,1:3) + gradH(3,k1)*dxidx(3,1:3)

!     ...accumulate for the load vector: $(f,q)$
         b_loc(k1) = b_loc(k1) + q*fval*weight

!     ...loop through H1 trial functions
         do k2=1,nrdofH

!        ...Piola transformation: $p \rightarrow \hat p$ and $\nabla p \rightarrow J^{-T} \hat \nabla \hat p$
            p = shapH(k2)
            dp(1:3) = gradH(1,k2)*dxidx(1,1:3) + gradH(2,k2)*dxidx(2,1:3) + gradH(3,k2)*dxidx(3,1:3)

!        ...accumulate for the stiffness matrix: $(\nabla p, \nabla q)$
            a_loc(k1,k2) = a_loc(k1,k2) + weight * (dq(1)*dp(1) + dq(2)*dp(2) + dq(3)*dp(3))

   enddo; enddo; enddo
\end{lstlisting}
	}
\end{itemize}

This concludes the list of necessary input files and routines required for defining the application code from the library-perspective. However, the user is encouraged to take a look at the remaining files within the \file{POISSON/GALERKIN} directory which include the driver \routine{main} and a variety of auxiliary files. In a future version of the user manual, we will include a discussion of these auxiliary files as well.

\subsection{DPG primal implementation}
\label{subsec:poisson-ultraweak}

Broken primal DPG formulation:
\[
\left\{
\begin{array}{llll}
	(u, \hat \sigma_n) \in H^1(\Omega) \times H^{-1/2}(\Gamma_h): u = u_0 \text{ on } \Gamma \, , \\[5pt]
	(\nabla u, \nabla v) - \lb \hat \sigma_n , v \rb_{\Gamma_h} 
	= (f,v) \, ,\quad v \in H^1(\Omega_h) \, .
\end{array}
\right.
\]

Compared to the Galerkin FE implementation, the primal DPG implementation is mostly different in the \routine{elem} routine.

The implementation is provided in \file{problems/POISSON/PRIMAL\_DPG}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linear Elasticity Problems}
\label{sec:elasticity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{Galerkin implementation}
%\label{subsec:maxwell-galerkin}

Linear elasticity will be added in a future version of the user manual.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maxwell Problems}
\label{sec:maxwell}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For time-harmonic Maxwell problems, the solution is complex-valued; the \hp3D library must therefore be compiled with preprocessing flag \code{\var{COMPLEX}=1}.

\begin{itemize}
\item
{
Linear time-harmonic Maxwell equations:
\begin{alignat*}{3}
	\curl \bs E + i \omega \mu \bs H
	&= \bs 0 &\quad \text{in } \Omega \, , \\
	\curl \bs H - (i \omega \eps + \sigma) \bs E 
	&= \bs J^{\text{imp}} &\quad \text{in } \Omega \, , \\
	\bs n \times \bs E &= \bs n \times \bs E_0 &\quad \text{on } \Gamma \, .
	test
\end{alignat*}
}
\item
{
Curl--curl formulation:
\begin{alignat*}{3}
	\curl (\mu^{-1} \curl \bs E) - (\omega^2 \eps - i \omega \sigma) \bs E
	&= -i \omega \bs J^{\text{imp}}  &\quad \text{in } \Omega \, , \\
	\bs n \times \bs E &= \bs n \times \bs E_0 &\quad \text{on } \Gamma \, .
	test
\end{alignat*}
}
\item
{
Classical variational formulation:
\[
\left\{
\begin{array}{lll}
	\bs E \in \Hcurl : \bs n \times \bs E = \bs n \times \bs E_0 \text{ on } \Gamma \, , \\[5pt]
	(\mu^{-1} \curl \bs E,\curl \bs F)_\Omega - ((\omega^2 \eps - i \omega \sigma) \bs E, \bs F)_\Omega
	= -i \omega (\bs J^{\text{imp}}, \bs F)_\Omega \, , \\[5pt]
	\hfill
	\quad \bs F \in \Hcurl \, : \, \bs n \times \bs F = \bs 0 \text{ on } \Gamma \, .
\end{array}
\right.
\]
The formulation involves just one unknown $\bs E \in \Hcurl$, defined on the whole domain.
}
\end{itemize}

\subsection{Galerkin implementation}
\label{subsec:maxwell-galerkin}

The implementation is provided in \file{problems/MAXWELL/GALERKIN}.

\subsection{DPG ultraweak implementation}
\label{subsec:maxwell-galerkin}

Ultraweak Maxwell will be added in a future version of the user manual.



%\input{Chapters/APPENDIX_A_EXAMPLES/comments}


